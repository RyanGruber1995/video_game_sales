# Part 1: Data Normalization

### 1.1: Overview

Although this dataset came from a public source and was mostly in a format that was usable, I took this opportunity to explore the data and discovered that the table could be optimized. The following is a screenshot of the columns and the first few rows of the raw data set:

<br />

![](https://github.com/RyanGruber1995/video_game_sales/blob/main/screenshots/data_normalization.PNG)

<br />

I identified three different attributes that could be broken out into different tables: Platform, Genre, and Publisher. These columns contain string data and can have multiple of the same value within their respective columns, e.g. having 'Nintendo' multiple times per the screenshot. Even though this particular dataset is able to fit in a spreadsheet, this would not be an ideal situation for a much larger dataset and processing time for running SQL queries would be reduced. Using Google Sheets, I created these three new tables, created ids for each table (primary keys), and mapped the ids to the games table which was created by taking a copy of the raw data and adding in new columns to map the ids to the new tables. The process for creating the platform, genre, and publisher tables were the same, so I will walk through the process of creating the platform table which was then applied to the other tables.

### 1.2: Creating Tables

I created two columns for the platform table: *platform_id* and *platform_name*. *platform_name* was generated by taking the unique values of the platform column from the raw data, and although unnecessary, I sorted the values alphabetically. *platform_id* was generated by starting at 1 and incrementing the value by 1 for each row. Below is a screenshot of the first few rows of the platform table along with the formula used to generate *platform_name*:

<br />

![](https://github.com/RyanGruber1995/video_game_sales/blob/main/screenshots/secondary_table_creation.PNG)

<br />

This created the first inconsistency by separating data because '2600' was formatted as a number, and I converted the entire column in both the platform and games tables to ensure the same data type.

<br />

Once these tables were created, it was time to finalize making the games table. To do this, I mapped the record for each of these three attributes to their respective tables by using an INDEX/MATCH function. Below is a screenshot of the formula and mapping process used for the *platform_id* with the same methodology being applied to the other id columns:

<br />

![](https://github.com/RyanGruber1995/video_game_sales/blob/main/screenshots/id_creation.PNG)

<br />

Because I wanted to remove the platform, genre, and publisher columns, and their respective id columns were referencing these columns, I needed to hardcode everything so those columns could be removed without causing errors. The [vgsales_draft.xlsx](https://github.com/RyanGruber1995/video_game_sales/blob/main/vgsales_draft.xlsx) file keeps track of the formulas I created before hardcoding and removing columns while the [vgsales_final.xlsx](https://github.com/RyanGruber1995/video_game_sales/blob/main/vgsales_final.xlsx) file shows the finalized tables that were uploaded into BigQuery for further analysis.

<br />

# Part 2: Data Exploring and Cleaning

The first thing I did was create a dataset called vgsales as well as tables for the four tables that were created during the data normalization process as shown here:

<br />

![](https://github.com/RyanGruber1995/video_game_sales/blob/main/screenshots/BigQuery_tables.PNG)

<br />

I initially took some time to explore the data and confirm that the data was ready for use. The first issue I came across was the schema of the games table as the data type of the year column was a string. Upon further analysis I noticed that some games had a year of 'N/A' as either the year was probably unknown or just not entered. By running the following code, I discovered that 271 games had this issue. It wouldn't be hard to fix this by researching when those games were released and updating them to have the complete dataset, but as there are so many to account for I decided to remove those observations.

    # Count number of rows that have year as 'N/A'
    SELECT COUNT(*)
    FROM vgsales.games
    WHERE year = "N/A"

    # Delete rows where year is unknown
    DELETE FROM vgsales.games WHERE year = "N/A"

I know from the site where I pulled this dataset that the data tracked games since 1980, but not necessarily what the most recent year was. To find this out I ran the following query and got the following output:

    # Count games from each year
    SELECT 
      year,
      COUNT(*) AS num_of_games
    FROM vgsales.games
    GROUP BY year
    ORDER BY year ASC

| year 	| num_of_games |
| :---  | :--- |
1980	| 9    
1981	| 46
1982	| 36
1983	| 17
1984	| 14
1985	| 14
1986	| 21
1987	| 16
1988	| 15
1989	| 17
1990	| 16
1991	| 41
1992	| 43
1993	| 60
1994	| 121
1995	| 219
1996	| 263
1997	| 289
1998	| 379
1999	| 338
2000	| 349
2001	| 482
2002	| 829
2003	| 775
2004	| 763
2005	| 941
2006	| 1008
2007	| 1202
2008	| 1428
2009	| 1431
2010	| 1259
2011	| 1139
2012	| 657
2013	| 546
2014	| 582
2015	| 614
2016	| 344
2017	| 3
2020	| 1

<br />

Although the distribution is not uniform for each year, it makes sense that there are way fewer games in the earlier years as not as many games were released compared to later years and was harder to track every game that was released. However, I did find it interesting to see that only 3 games were released in 2017 and only 1 game was released in 2020 while no games in 2018 nor 2019 were recorded. Let's see which games those are:

    # Get the games that were "released" in 2017 and 2020
    SELECT 
        name,
        year
    FROM vgsales.games
    WHERE year = 2017 OR year = 2020

| name | year |
| :--- | :--- |
| Imagine: Makeup Artist | 2020
| Phantasy Star Online 2 Episode 4: Deluxe Package | 2017
| Phantasy Star Online 2 Episode 4: Deluxe Package | 2017
| Brothers Conflict: Precious Baby | 2017

Since there were only a few games that were possibly recorded incorrectly, I did a quick Google search to see when these games were released and confirmed the years were wrong. The following query resolved this issue:

    # Update years for games in 2017 and 2020
    UPDATE vgsales.games
    SET year = 2009
    WHERE name = "Imagine: Makeup Artist"

    UPDATE vgsales.games
    SET year = 2007
    WHERE name = "Phantasy Star Online 2 Episode 4: Deluxe Package"

    UPDATE vgsales.games
    SET year = 2016
    WHERE name = "Brothers Conflict: Precious Baby"

Running the query to get the games released in 2017 or 2020 posed another issue - possible duplicate data as one of the games showed up twice. I ran the first following query and got back 2,717 games that had duplicate names, but the second query that selected the unique rows produced the same number of rows (16,327) as the original games table meaning that there are no duplicate entries:

    # Find duplicate names and number of occurrences
    SELECT
      DISTINCT name,
      COUNT(name) AS num_instances
    FROM vgsales.games
    GROUP BY name
    HAVING num_instances > 1

    # Find unique records
    SELECT DISTINCT *
    FROM vgsales.games

Upon further investigation, the games that had duplicate names were either instances of a game that were released on different platforms or remakes of the same game that were released in later years. Now that the data has been explored and cleaned, let's do some analysis!

<br />

# Part 3: Tableau

### 3.1 Overview

The [Video Game Sales](https://public.tableau.com/app/profile/ryan.gruber/viz/VideoGameSales_16984594653460/MarketTrends) dashboard can be found on my [Tableau Online Portfolio](https://public.tableau.com/app/profile/ryan.gruber/vizzes).

The first step I took to create a dashboard for this dataset was by deciding what trends and relationships I wanted to present that would be helpful for decision makers. Then, I decided what chart types would be best to represent that data, being mindful of using different kinds of charts. And finally, I drew a rough sketch of the layout for the dashboard to efficiently build it in a visually-appealing way. I also acted as if I was an analyst for my favorite game company, Nintendo, by analyzing the entire video game market and seeing how well Nintendo was performing compared to other publishers.

The goal of this dashboard was to easily compare Nintendo's trends along with those in the entire market by having identical dashboards that stakeholders can switch between. The 'Market Trends' dashboard represents the overall market analysis while the 'Nintendo Market Analysis' dashboard shows trends only for Nintendo. 

### 3.2 Chart Explanations

**KPIS:** The KPIs are totals that do not update when filters are applied which helps stakeholders identify percentages of the overall market. For example, for the entire video game market, action games brought in a total of $1,722M which is about 1/5 of the total sales.

**Sales By Region:** This donut chart shows the sales between the different regions in the dataset: NA, EU, JP and other along with the total sales, and represents the data when filters are applied.

**Sales By Genre:** This chart is a heatmap that shows the relationship between genre and region. The genres with the highest sales in each region are shaded with a darker red while the lower sales are a lighter red.

**Sales By Platform:** This treemap shows which platforms had the highest sales. The ones with larger sales are larger and shaded with a darker blue.

**Top 10 Publishers/Top 10 Games:** The Top 10 Publishers bar chart in the Market Trends dashboard compares the total sales by publisher but is limited to the top 10 publishers. Since no other publishers are being analyzed in the Nintendo dashboard, this chart was replaced by the top 10 games sold by Nintendo.

**Sales Over Time:** This is a hybrid chart combining a line chart and stacked bar chart. The line represents the total sales for each year, while the stacked bar chart shows the total sales by year for each region. There is also another line across the whole chart that represents the average sales.

<br />

# Part 4: Nintendo Analysis

Continuing the observations for Nintendo, I wanted to perform a deeper analysis in Nintendo's data with SQL. I came up with the following questions that could be asked by a stakeholder.

**Question 1:** *"What is our best selling game series?"* 

To answer this, I would need to categorize each game as different games can belong to the same series. To create a variable and make sure it's working I ran the following query with the following results (first 5 lines only):

    # Categorize Nintendo games
    SELECT
      name,
      CASE
        WHEN name LIKE '%Mario%' THEN 'Mario'
        WHEN name LIKE '%Pok%mon%' THEN 'Pokemon'
        WHEN name LIKE '%Zelda%' THEN 'Zelda'
        WHEN name LIKE '%Donkey Kong%' THEN 'Donkey Kong'
        WHEN name LIKE '%Kirby%' THEN 'Kirby'
        WHEN name LIKE '%Metroid%' THEN 'Metroid'
        WHEN name LIKE '%Animal Crossing%' THEN 'Animal Crossing'
        ELSE 'Other'
      END AS game_series
    FROM vgsales.games g JOIN vgsales.publisher p ON g.publisher_id = p.publisher_id
    WHERE p.publisher_name = 'Nintendo'
    ORDER BY game_id ASC

| name	| game_series |
| :---  | :---        |
| Wii Sports	| Other
| Super Mario Bros.	| Mario
| Mario Kart Wii	| Mario
| Wii Sports Resort	| Other
| Pokemon Red/Pokemon Blue	| Pokemon

There are numerous game series that Nintendo has released, but I chose only a couple that came to mind for this analysis. Now that I confirmed that the variable *game_series* is working, I can find which series has the highest sales while excluding any 'other' series:

    # Sort game series by sales
    SELECT
      CASE
        WHEN name LIKE '%Mario%' THEN 'Mario'
        WHEN name LIKE '%Pok%mon%' THEN 'Pokemon'
        WHEN name LIKE '%Zelda%' THEN 'Zelda'
        WHEN name LIKE '%Donkey Kong%' THEN 'Donkey Kong'
        WHEN name LIKE '%Kirby%' THEN 'Kirby'
        WHEN name LIKE '%Metroid%' THEN 'Metroid'
        WHEN name LIKE '%Animal Crossing%' THEN 'Animal Crossing'
        ELSE "Other"
      END AS game_series,
      ROUND(SUM(Global_Sales),2) AS total_sales_millions
    FROM vgsales.games
    GROUP BY game_series
    HAVING game_series != 'Other'
    ORDER BY total_sales_millions DESC

| game_series	| total_sales_millions |
| :---          | :---                 |
| Mario	| 555.26
| Pokemon	| 250.57
| Zelda	| 82.37
| Donkey Kong	| 60.71
| Kirby	| 37.28
| Animal Crossing	| 32.59
| Metroid	| 17.94

Here we can clearly see that the Mario series is the highest grossing series with a total of $555.26 million sales. 

**Question 2:** *"Do Pokemon games sell better for handheld or console devices?"* 

For this question, I would need to categorize the platforms with GameBoy (GB), GameBoy Advanced (GBA), Nintendo DS (DS), and Nintendo 3DS (3DS) as the handheld devices with the other platforms being consoles and comparing the total and average sales for each device:

    # Compare sales of handheld vs console Pokemon games
    SELECT
      CASE
        WHEN platform_name IN ('GB', 'GBA', 'DS', '3DS') THEN 'Handheld'
        ELSE 'Console'
      END AS device,
      ROUND(SUM(Global_Sales), 2) AS total_sales_millions,
      ROUND(AVG(Global_Sales), 2) AS average_sales_millions
    FROM vgsales.games g JOIN vgsales.platform p ON g.platform_id = p.platform_id
    WHERE name LIKE '%Pok%mon%'
    GROUP BY device

| device	| total_sales_millions	| average_sales_millions |
| :--- | :--- | :--- |
| Handheld	| 232.25	| 5.96 |
| Console	| 18.32	| 2.04 |

Here we can see that there's not much of a contest between the two with Pokemon games on handheld devices not only selling significantly more in total, but almost three times as much per game on average. This would be important knowledge if Nintendo was planning on releasing a new Pokemon game to think about which device to release it on.

**Question 3:** *"Do Pokemon main series games sell better when they are the first released main series game on a new platform?"* 

In other words, if there were five main series games released on a platform, does the game that was released first sell better than the other four? To look into this, I wrote the following query:

    #Group main series Pokemon game by platform
    WITH main_series_games AS ( -- create a main_series variable to filter later
    SELECT *,
      CASE WHEN name IN 
        (
          'Pokemon Red/Pokemon Blue',
          'Pokemon Gold/Pokemon Silver',
          'Pokemon Diamond/Pokemon Pearl',
          'Pokemon Ruby/Pokemon Sapphire',
          'Pokemon Black/Pokemon White',
          'Pokémon Yellow: Special Pikachu Edition',
          'Pokemon X/Pokemon Y',
          'Pokemon HeartGold/Pokemon SoulSilver',
          'Pokemon Omega Ruby/Pokemon Alpha Sapphire',
          'Pokemon FireRed/Pokemon LeafGreen',
          'Pokemon Black 2/Pokemon White 2',
          'Pokémon Platinum Version',
          'Pokémon Emerald Version',
          'Pokémon Crystal Version'
        ) THEN 1
        ELSE 0
      END AS main_series
    FROM vgsales.games g JOIN vgsales.platform p ON g.platform_id = p.platform_id
    )
    SELECT -- create a table with relevant columns, filter for main series games, first partitioning by platform, and then sorting by year
      game_id,
      name,
      platform_name,
      year,
      Global_Sales 
    FROM main_series_games
    WHERE main_series = 1
    ORDER BY platform_name ASC, year ASC

| game_id	| name	| platform_name	| year	| Global_Sales |
| :--- | :--- | :--- | :--- | :--- |
| 33	| Pokemon X/Pokemon Y	| 3DS	| 2013	| 14.35 |
| 50	| Pokemon Omega Ruby/Pokemon Alpha Sapphire	| 3DS	| 2014	| 11.33 |
| 21	| Pokemon Diamond/Pokemon Pearl	| DS	| 2006	| 18.36 |
| 89	| Pokémon Platinum Version	| DS	| 2008	| 7.84 |
| 46	| Pokemon HeartGold/Pokemon SoulSilver	| DS	| 2009	| 11.9 |
| 27	| Pokemon Black/Pokemon White	| DS	| 2010	| 15.32 |
| 82	| Pokemon Black 2/Pokemon White 2	| DS	| 2012	| 8.33 |
| 5	    | Pokemon Red/Pokemon Blue	| GB	| 1996	| 31.37 |
| 31	| Pokémon Yellow: Special Pikachu Edition	| GB	| 1998	| 14.64 |
| 13	| Pokemon Gold/Pokemon Silver	| GB	| 1999	| 23.1 |
| 133	| Pokémon Crystal Version	| GB	| 2000	| 6.39 |
| 26	| Pokemon Ruby/Pokemon Sapphire	| GBA	| 2002	| 15.85 |
| 59	| Pokemon FireRed/Pokemon LeafGreen	| GBA	| 2004	| 10.49 |
| 131	| Pokémon Emerald Version	| GBA	| 2004	| 6.41 |

<br /> 

This is a lot to take in, so let me break this down a little bit. The first thing to do was creating a table to perform this analysis on by identifying what the main series Pokemon games were. By manually looking through the data and having a strong understanding of every Pokemon game, I was able to find the ones that were listed in this dataset. These were manually entered to create the *main_series* attribute. The main_series_games table combined the games table that has all of the relevant information with the platform table that has the platform names - otherwise I would have only been able to partition the table by *platform_id.* Then, by taking that table and choosing relevant columns, I filtered the table to only include the main series games, partitioned the table by platform, and then sorted the table year. The partitioning and sorting allows the table to be grouped by platform and then within those groups to then be sorted by release date which allows us to see the chronological order each game was released on each platform. By analyzing this table, you can see that the first game that was released on each platform had the highest sales for that platform. This is important to know because if Nintendo were to release a new platform, it would be critical to think about the spending and marketing for that game much more than they do for their other games.

That concludes the SQL analysis of this project. For a full list of queries that were ran please refer to the [SQL_Queries.sql](https://github.com/RyanGruber1995/video_game_sales/blob/main/SQL_Queries.sql) file. The final part of this project is taking this data and visualizing it in Tableau, creating a dashboard that would be useful for stakeholders.

# Part 5: Conclusion


